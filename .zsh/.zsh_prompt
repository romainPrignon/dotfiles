function my_git_commits_behind() {
  if $(echo "$(command git log HEAD..@{upstream} 2> /dev/null)" | grep '^commit' &> /dev/null); then
    COMMITS=$(command git log HEAD..@{upstream} | grep '^commit' | wc -l | tr -d ' ')
    echo "$ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX$ZSH_THEME_GIT_PROMPT_BEHIND$COMMITS$ZSH_THEME_GIT_COMMITS_BEHIND_SUFFIX"
  fi
}

function my_git_commits_ahead() {
  if $(echo "$(command git log @{upstream}..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
    COMMITS=$(command git log @{upstream}..HEAD | grep '^commit' | wc -l | tr -d ' ')
    echo "$ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX$ZSH_THEME_GIT_PROMPT_AHEAD$COMMITS$ZSH_THEME_GIT_COMMITS_AHEAD_SUFFIX"
  fi
}

function my_git_prompt_info() {
  if [[ "$(command git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]; then
    ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
    echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}|$(parse_git_dirty)$(my_git_commits_ahead)$(my_git_commits_behind)$ZSH_THEME_GIT_PROMPT_SUFFIX"
  fi
}


PROMPT='$NEWLINE%{$fg_bold[green]%}%n%{$reset_color%} %{$fg_bold[blue]%}%~%{$reset_color%} $(my_git_prompt_info)%{$reset_color%}%B$%b '
RPS1="${return_code}"

NEWLINE=$'\n'
ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg[white]%}[%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$fg[white]%}] %{$reset_color%}"
ZSH_THEME_GIT_PROMPT_UNTRACKED=""
ZSH_THEME_GIT_PROMPT_ADDED=""
ZSH_THEME_GIT_PROMPT_CLEAN="v"
ZSH_THEME_GIT_PROMPT_DIRTY="*"
ZSH_THEME_GIT_PROMPT_MODIFIED=""
ZSH_THEME_GIT_PROMPT_RENAMED=""
ZSH_THEME_GIT_PROMPT_DELETED=""
ZSH_THEME_GIT_PROMPT_UNMERGED=""
ZSH_THEME_GIT_PROMPT_AHEAD="i"
ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX="|"
ZSH_THEME_GIT_PROMPT_BEHIND="!"
ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX="|"
