my_parse_git_dirty() {
  local SUBMODULE_SYNTAX=''
  local GIT_STATUS=''
  local CLEAN_MESSAGE='nothing to commit (working directory clean)'
  if [[ "$(command git config --get oh-my-zsh.hide-status)" != "1" ]]; then
    if [[ $POST_1_7_2_GIT -gt 0 ]]; then
          SUBMODULE_SYNTAX="--ignore-submodules=dirty"
    fi
    if [[ "$DISABLE_UNTRACKED_FILES_DIRTY" == "true" ]]; then
        GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} -uno 2> /dev/null | tail -n1)
    else
        GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} 2> /dev/null | tail -n1)
    fi
    if [[ -n $GIT_STATUS ]]; then
      INDEX=$(command git status --porcelain -b 2> /dev/null)
      STATUS=""
      if $(echo "$INDEX" | grep '^A  ' &> /dev/null); then
        STATUS="$ZSH_THEME_GIT_PROMPT_ADDED"
      elif $(echo "$INDEX" | grep '^M  ' &> /dev/null); then
        STATUS="$ZSH_THEME_GIT_PROMPT_ADDED"
      fi
      if $(echo "$INDEX" | grep '^UU ' &> /dev/null); then
        STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED"
      fi
      if [ -z "$STATUS" ]; then
        echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
      else
        echo "$STATUS"
      fi
    else
      echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
    fi
  else
    echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
  fi
}

function my_git_commits_behind() {
  if $(echo "$(command git log HEAD..@{upstream} 2> /dev/null)" | grep '^commit' &> /dev/null); then
    COMMITS=$(command git log HEAD..@{upstream} | grep '^commit' | wc -l | tr -d ' ')
    echo "$ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX$ZSH_THEME_GIT_PROMPT_BEHIND$COMMITS$ZSH_THEME_GIT_COMMITS_BEHIND_SUFFIX"
  fi
}

function my_git_commits_ahead() {
  if $(echo "$(command git log @{upstream}..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
    COMMITS=$(command git log @{upstream}..HEAD | grep '^commit' | wc -l | tr -d ' ')
    echo "$ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX$ZSH_THEME_GIT_PROMPT_AHEAD$COMMITS$ZSH_THEME_GIT_COMMITS_AHEAD_SUFFIX"
  fi
}

function my_git_prompt_info() {
  if [[ "$(command git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]; then
    ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
    echo "$ZSH_THEME_GIT_PROMPT_PREFIX%{$fg[white]%}${ref#refs/heads/}%{$reset_color%}%{$fg[white]%}$(my_git_commits_ahead)%{$reset_color%}%{$fg[white]%}$(my_git_commits_behind)%{$reset_color%}$ZSH_THEME_GIT_PROMPT_SEPARATOR$(my_parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
  fi
}

NEWLINE=$'\n'
ZSH_THEME_GIT_PROMPT_SEPARATOR="%{$fg[white]%}|%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg[white]%}[%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$fg[white]%}] %{$reset_color%}"
ZSH_THEME_GIT_PROMPT_UNTRACKED=""
ZSH_THEME_GIT_PROMPT_ADDED="%{$fg_bold[green]%}•%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_MODIFIED=""
ZSH_THEME_GIT_PROMPT_RENAMED=""
ZSH_THEME_GIT_PROMPT_DELETED=""
ZSH_THEME_GIT_PROMPT_UNMERGED="%{$fg_bold[red]%}■%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg_bold[red]%}±%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg_bold[green]%}√%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_AHEAD="%{$fg[white]%}↑%{$reset_color%}"
ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX=""
ZSH_THEME_GIT_PROMPT_BEHIND="%{$fg_bold[white]%}↓%{$reset_color%}"
ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX=""

PROMPT='${NEWLINE}%{$fg_bold[cyan]%}%n%{$reset_color%} %{$fg_bold[yellow]%}%~%{$reset_color%} $(my_git_prompt_info)%(!.%{$fg_bold[red]%}#%{$reset_color%}.%{$fg_bold[white]%}$%{$reset_color%}) '
